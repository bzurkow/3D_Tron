'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EffectComposer = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _CopyShader = require('./shader/CopyShader.js');

var _ShaderPass = require('./pass/ShaderPass.js');

var _MaskPass = require('./pass/MaskPass.js');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EffectComposer = exports.EffectComposer = function () {
  /**
   * EffectComposer handle a set of Passes and render them in a RenderTarget through a Renderer
   * @param  {THREE.WebGLRenderer} renderer : The renderer that will be used to render objects
   * @param  {THREE.WebGLRenderTarget} renderTarget : The renderTarget used to draw buffers and compose them
   */
  function EffectComposer(renderer, renderTarget) {
    (0, _classCallCheck3.default)(this, EffectComposer);

    this.$renderer = renderer;

    if (renderTarget === undefined) {
      var parameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        stencilBuffer: false
      };

      var size = renderer.getSize();

      renderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);
    }

    this.$renderTarget1 = renderTarget;
    this.$renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.$renderTarget1;
    this.readBuffer = this.$renderTarget2;
    this.passes = [];

    this.$copyPass = new _ShaderPass.ShaderPass(_CopyShader.CopyShader);
  }

  /**
   * Swap drawing buffers
   */


  (0, _createClass3.default)(EffectComposer, [{
    key: 'swapBuffers',
    value: function swapBuffers() {
      var tmp = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = tmp;
    }

    /**
     * Add a WHS.Pass to the composer, after all existing passes.
     * @param {WHS.Pass} pass : The pass to be added
     */

  }, {
    key: 'addPass',
    value: function addPass(pass) {
      if (!pass) return;
      var size = this.$renderer ? this.$renderer.getSize() : { width: 0, height: 0 };
      pass.setSize(size.width, size.height);
      this.passes.push(pass);
    }

    /**
     * Get the pass of the same unique name, otherwise undefined.
     * @param  {String} name : the unique name of the pass to find.
     * @return {WHS.Pass} The found Pass or undefined.
     */

  }, {
    key: 'getPass',
    value: function getPass(name) {
      return this.passes.filter(function (v) {
        return v.name === name;
      })[0];
    }

    /**
     * Get the pass index in the internal passes array.
     * @param  {String|WHS.Pass} passIndicator : The pass name or the pass instance.
     * @return {Number} The pass index or -1.
     */

  }, {
    key: 'getPassIndex',
    value: function getPassIndex(passIndicator) {
      var passName = typeof passIndicator === 'string' ? passIndicator : passIndicator.name;
      return this.passes.indexOf(this.getPass(passName));
    }

    /**
     * Add a pass after another one. Add the pass in first position if previous is not found.
     * @param {String|WHS.Pass} previousPassIndicator : The previous pass name or the previous pass instance.
     */

  }, {
    key: 'addPassAfter',
    value: function addPassAfter(previousPassIndicator, pass) {
      if (!pass) return;
      var index = this.getPassIndex(previousPassIndicator);
      index = index < 0 ? 0 : index + 1;
      this.insertPass(pass, index);
    }

    /**
     * Add a pass at the specified index.
     * @param  {WHS.Pass} pass : The pass instance to insert
     * @param  {Number} index : The index.
     */

  }, {
    key: 'insertPass',
    value: function insertPass(pass, index) {
      if (pass) this.passes.splice(index, 0, pass);
    }

    /**
     * Remove a pass from this composer.
     * @param  {String|WHS.Pass} passIndicator : The pass name or the pass instance.
     */

  }, {
    key: 'removePass',
    value: function removePass(passIndicator) {
      var index = this.getPassIndex(passIndicator);
      if (index > -1) this.passes.splice(index, 1);
    }

    /**
     * Render the EffectComposer, and all its passes.
     * @param  {Number} delta : The delta time since the last frame.
     */

  }, {
    key: 'render',
    value: function render(delta) {
      for (var i = 0, il = this.passes.length, pass, maskActive = false; i < il; i++) {
        pass = this.passes[i];

        if (pass.enabled === false) continue;

        pass.render(this.$renderer, this.writeBuffer, this.readBuffer, delta, maskActive);

        if (pass.needsSwap) {
          if (maskActive) {
            var context = this.$renderer.context;

            context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);
            this.$copyPass.render(this.$renderer, this.writeBuffer, this.readBuffer, delta);
            context.stencilFunc(context.EQUAL, 1, 0xffffffff);
          }

          this.swapBuffers();
        }

        if (_MaskPass.MaskPass !== undefined) {
          if (pass instanceof _MaskPass.MaskPass) maskActive = true;else if (pass instanceof _MaskPass.ClearMaskPass) maskActive = false;
        }
      }
    }

    /**
     * Set another renderTarget.
     * @param  {THREE.WebGLRenderTarget} renderTarget : The new renderTarget to use.
     */

  }, {
    key: 'reset',
    value: function reset(renderTarget) {
      if (renderTarget === undefined) {
        var size = this.$renderer.getSize();

        renderTarget = this.$renderTarget1.clone();
        renderTarget.setSize(size.width, size.height);
      }

      this.$renderTarget1.dispose();
      this.$renderTarget2.dispose();
      this.$renderTarget1 = renderTarget;
      this.$renderTarget2 = renderTarget.clone();

      this.writeBuffer = this.$renderTarget1;
      this.readBuffer = this.$renderTarget2;
    }

    /**
     * Resize the renderTarget and all the EffectComposer passes.
     * @param {Number} width : The width in pixels
     * @param {Number} height : The height in pixels
     */

  }, {
    key: 'setSize',
    value: function setSize(width, height) {
      this.$renderTarget1.setSize(width, height);
      this.$renderTarget2.setSize(width, height);

      for (var i = 0; i < this.passes.length; i++) {
        this.passes[i].setSize(width, height);
      }
    }
  }]);
  return EffectComposer;
}();